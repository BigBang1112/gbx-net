@using Blazored.LocalStorage
@using BlazorMonaco.Editor


@using global::OmniSharp.Models
@using global::OmniSharp.Models.SignatureHelp
@using global::OmniSharp.Models.v1.Completion
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using System.Text
@inject HttpClient Http
@inject IGbxService GbxService
@inject IJSRuntime JS
@inject IDownloadStreamService DownloadService
@inject ISyncLocalStorageService LocalStorage
@inject EditorServices EditorServices

<div class="section section-editor hoverable" style="padding: 4px" @onclick="ExpandEditor">
    <div>Try scripting with C#</div>
    <img style="height: 42px;" src="img/editor.png"/>
</div>
<style>
    .suggest-details-container .suggest-details .rendered-markdown {
        overflow: auto !important;
    }

    .suggest-details-container .suggest-details {
        width: 400px !important;
        max-width: 600px !important;
    }
</style>
<script>
    let dotNetRef;

    function setDotNetRef(ref) {
        dotNetRef = ref;
    }


    // Register folding range provider for usings
    monaco.languages.registerFoldingRangeProvider("csharp", {
        provideFoldingRanges: function (model, context, token) {
            const ranges = [];
            const lines = model.getLinesContent();

            let i = 0;
            while (i < lines.length) {
                if (lines[i].startsWith("using ")) {
                    let start = i + 1;
                    let end = start;

                    while (end < lines.length && lines[end].startsWith("using ")) {
                        end++;
                    }

                    ranges.push({
                        start: start,
                        end: end,
                        kind: monaco.languages.FoldingRangeKind.Imports
                    });

                    i = end;
                } else {
                    i++;
                }
            }

            return ranges;
        }
    });


    window.foldAllImports = async () => {
        const editor = monaco.editor.getEditors()[0];
        editor.setPosition({lineNumber: 1, column: 1})
        await editor.getAction("editor.fold").run();
        const lines = editor.getValue().split("\n");
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes("public static void") && lines.length >= i + 3) {
                editor.setPosition({lineNumber: i + 3, column: 9})
                break;
            }
        }
        editor.focus()
    };
    window.addMonacoShortcuts = () => {
        const editor = monaco.editor.getEditors()[0];
        editor._domElement.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                dotNetRef.invokeMethodAsync("SaveNote")
            }
        });
        editor._domElement.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
                e.preventDefault();
                dotNetRef.invokeMethodAsync("RunUserCode")
            }
        }, true);
    };

    window.dialogHelper = {
        showModal: (dialog) => dialog.showModal(),
        close: (dialog) => dialog.close()
    };

    let lastDebounceInvocation = Date.now();
    let debounceDelay = 100;

    function debounce(fn, increment = 100, maxDelay = 300, resetDelay = 1000) {
        if (Date.now() - lastDebounceInvocation > resetDelay) {
            debounceDelay = 100;
        }
        lastDebounceInvocation = Date.now();
        let timerId;
        return function (...args) {
            clearTimeout(timerId);
            return new Promise(resolve => {
                timerId = setTimeout(() => {
                    debounceDelay = Math.min(debounceDelay + increment, maxDelay);
                    resolve(fn.apply(this, args))
                }, debounceDelay);
            });
        };
    }

    const debouncedCompletion = debounce(provideCompletionItems);

    function registerProviders() {

        window.monaco.languages.registerCompletionItemProvider("csharp", {
            triggerCharacters: [".", " "],
            resolveCompletionItem: (item, token) => {
                return item;
            },
            provideCompletionItems: async (model, position, context) => {
                return await debouncedCompletion(model, position, context, dotNetRef);
            }
        });

        window.monaco.languages.registerSignatureHelpProvider("csharp", {
            signatureHelpTriggerCharacters: ['('],
            provideSignatureHelp: async (model, position) => {
                return await provideSignatureHelp(model, position, dotNetRef)
            }
        });

        window.monaco.languages.registerHoverProvider("csharp", {
            provideHover: async (model, position) => {
                return await provideHover(model, position, dotNetRef)
            }
        });
    }

    let _lastCompletions;

    async function provideCompletionItems(model, position, context, dotnetHelper) {
        let request = _createRequest(position);
        request.CompletionTrigger = (context.triggerKind + 1);
        request.TriggerCharacter = context.triggerCharacter;

        try {
            const code = model.getValue();
            const response = await dotnetHelper.invokeMethodAsync("GetCompletionAsync", code, request);
            const mappedItems = response.items.map(_convertToVscodeCompletionItem);

            let lastCompletions = new Map();

            for (let i = 0; i < mappedItems.length; i++) {
                lastCompletions.set(mappedItems[i], response.items[i]);
            }

            _lastCompletions = lastCompletions;
            return {suggestions: mappedItems};
        } catch (error) {
            return;
        }
    }

    async function provideSignatureHelp(model, position, dotnetHelper) {

        let req = _createRequest(position);

        try {
            let code = model.getValue();
            let res = await dotnetHelper.invokeMethodAsync("GetSignatureHelpAsync", code, req);

            if (!res) {
                return undefined;
            }

            let ret = {
                signatures: [],
                activeSignature: res.activeSignature,
                activeParameter: res.activeParameter
            }

            for (let signature of res.signatures) {

                let signatureInfo = {
                    label: signature.label,
                    documentation: signature.structuredDocumentation.summaryText,
                    parameters: []
                }

                ret.signatures.push(signatureInfo);

                for (let parameter of signature.parameters) {
                    let parameterInfo = {
                        label: parameter.label,
                        documentation: _getParameterDocumentation(parameter)
                    }

                    signatureInfo.parameters.push(parameterInfo);
                }
            }

            return {
                value: ret,
                dispose: () => {
                }
            }
        } catch (error) {
            return undefined;
        }
    }

    async function provideHover(document, position, dotnetHelper) {
        let request = _createRequest(position);
        try {
            const response = await dotnetHelper.invokeMethodAsync("GetQuickInfoAsync", request);
            if (!response || !response.markdown) {
                return undefined;
            }

            return {
                contents: [
                    {
                        value: response.markdown
                    }
                ]
            }
        } catch (error) {
            return undefined;
        }
    }

    function setDiagnostics(diagnostics, uri) {

        var model = monaco.editor.getModel(uri)

        diagnostics.forEach(diagnostic => {
            diagnostic.startLineNumber = diagnostic.start.line + 1;
            diagnostic.startColumn = diagnostic.start.character + 1;

            diagnostic.endLineNumber = diagnostic.end.line + 1;
            diagnostic.endColumn = diagnostic.end.character + 1;
        });

        window.monaco.editor.setModelMarkers(model, "owner", diagnostics);
    }

    function _getParameterDocumentation(parameter) {
        let summary = parameter.documentation;
        if (summary.length > 0) {
            let paramText = `**${parameter.name}**: ${summary}`;
            return {
                value: paramText
            };
        }

        return "";
    }

    function _convertToVscodeCompletionItem(omnisharpCompletion) {
        const mapRange = function (edit) {
            const newStart = {
                lineNumber: edit.startLine + 1,
                column: edit.startColumn + 1
            };
            const newEnd = {
                lineNumber: edit.endLine + 1,
                column: edit.endColumn + 1
            };
            return {
                startLineNumber: newStart.lineNumber,
                startColumn: newStart.column,
                endLineNumber: newEnd.lineNumber,
                endColumn: newEnd.column
            };
        };

        const mapTextEdit = function (edit) {
            return new TextEdit(mapRange(edit), edit.NewText);
        };

        const additionalTextEdits = omnisharpCompletion.additionalTextEdits?.map(mapTextEdit);

        const newText = omnisharpCompletion.textEdit?.newText ?? omnisharpCompletion.insertText;
        const insertText = newText;

        const insertRange = omnisharpCompletion.textEdit ? mapRange(omnisharpCompletion.textEdit) : undefined;

        return {
            label: {label: omnisharpCompletion.label, description: omnisharpCompletion.detail ?? ""},
            kind: omnisharpCompletion.kind - 1,
            detail: "",
            documentation: {
                value: omnisharpCompletion.documentation,
                kind: "markdown"
            },
            commitCharacters: omnisharpCompletion.commitCharacters,
            preselect: omnisharpCompletion.preselect,
            filterText: omnisharpCompletion.filterText,
            insertText: insertText,
            range: insertRange,
            tags: omnisharpCompletion.tags,
            sortText: omnisharpCompletion.sortText,
            additionalTextEdits: additionalTextEdits,
            keepWhitespace: true
        };
    }

    function _createRequest(position) {

        let Line, Column;

        Line = position.lineNumber - 1;
        Column = position.column - 1;

        let request = {
            Line,
            Column
        };

        return request;
    }

</script>

@if (Expanded)
{
    <div class="overlay">
        <div class="section section-log-maximized section-editor-overlay">
            <div class="notes-wrapper">
                <h3 class="notes-header">Notes</h3>
                <div class="notes-container">
                    @if (noteManager is not null)
                    {
                        @foreach (var note in noteManager.Notes.Values.OrderByDescending(x => x.UpdatedAt))
                        {
                            @if (note == noteManager.SelectedNote)
                            {
                                <div class="note-card selected-note">
                                    <img @onclick="DuplicateSelectedNote" style="filter: invert(1);" src="img/copy.png" title="Create a copy" alt="Copy"/>
                                    <input @bind="note.Name" @oninput="OnNoteNameChanged"/>
                                    <img @onclick="RemoveSelectedNote" src="img/bin.png" alt="Del"/>
                                </div>
                            }
                            else
                            {
                                <div class="note-card hoverable" @onclick="() => OnNoteClick(note.Id)">
                                    @note.Name
                                </div>
                            }
                        }
                    }
                </div>
                <div style="margin-top: auto; display: flex; flex-direction: column; gap: 1rem;">
                    <button class="button button-centered" @onclick="AddNewNote">Add new note</button>
                    <div style="display: flex;justify-content: space-between;gap: 1rem;">
                        <ButtonWithDialog DialogTitle="Import" ButtonText="Import" CssClass="button-centered">
                            <div class="import-wrapper">
                                <SectionLoadGbx OnImport="OnImportAsync" ImportMessage="Import json files with notes here.."></SectionLoadGbx>
                                <button class="button " @onclick="ImportFromClipboard">From clipboard</button>
                            </div>
                        </ButtonWithDialog>
                        <ButtonWithDialog DialogTitle="Select notes to export" ButtonText="Export" CssClass="button-centered">
                            <div class="export-wrapper">
                                <div class="controls-group">
                                    <button class="button button-centered" @onclick="ExportSelectAll">Select all</button>
                                    <button class="button button-centered" @onclick="ExportUnselectAll">Unselect all</button>
                                </div>
                                <div class="export-notes-container">
                                    @if (noteManager is not null)
                                    {
                                        @foreach (var note in noteManager.Notes.Values.OrderByDescending(x => x.UpdatedAt))
                                        {
                                            <div>
                                                <input type="checkbox"
                                                       id="@note.Id"
                                                       checked="@selectedForExport.Contains(note.Id)"
                                                       @onchange="e => OnExportCheckboxChanged(note.Id, e.Value)"/>
                                                <label for="@note.Id">@note.Name</label>
                                            </div>
                                        }
                                    }
                                </div>
                                <div class="controls-group">
                                    <button class="button button-centered" @onclick="ExportToFile">To file</button>
                                    <button class="button button-centered" @onclick="ExportToClipboard">To clipboard</button>
                                </div>
                            </div>
                        </ButtonWithDialog>
                    </div>
                    <ButtonWithDialog DialogTitle="Samples" ButtonText="Samples" CssClass="button-centered">
                        <div class="sample_list">
                            @foreach (var kvp in availableSamples.OrderBy(k => k.Key))
                            {
                                <div class="sample_container">
                                    <div class="sample_name">@kvp.Key</div>
                                    <button class="button" @onclick="() => UseSample(kvp.Value)">Use</button>
                                </div>
                            }
                        </div>
                    </ButtonWithDialog>
                </div>
            </div>
            <div class="editor-wrapper @(SplitViewEnabled ? "with-tree" : "without-tree")">
                <div class="editor-controls">
                    <div class="controls-group">
                        <button class="button run-button" @onclick="RunUserCode" title="ctrl+enter">Run</button>
                        <button class="button " @onclick="SaveNote" title="ctrl+s">Save</button>
                        <ButtonWithDialog DialogTitle="Select DLL" ButtonText="Select DLL">
                            <div class="dll-options">
                                @foreach (var kvp in availableDlls.OrderBy(k => k.Key))
                                {
                                    <div>
                                        <input type="checkbox"
                                               checked="@kvp.Value"
                                               id="@kvp.Key"
                                               @onchange="e => OnDllCheckboxChanged(kvp.Key, e.Value)"/>
                                        <label for="@kvp.Key">@kvp.Key</label>
                                    </div>
                                }
                            </div>
                        </ButtonWithDialog>
                    </div>
                    <div class="controls-group">
                        <ButtonWithDialog DialogTitle="Docs" ButtonText="Docs">
                            <div>
                                <h3 style="text-align: center">Useful shortcuts</h3>
                                <ul class="shortcuts-list">
                                    <li><b>CTRL + S</b> <span>save</span></li>
                                    <li><b>CTRL + Enter</b> <span>execute code</span></li>
                                    <li><b>CTRL + Space</b> <span>get suggestions</span></li>
                                </ul>
                                <h3 style="text-align: center">More info <a href="https://github.com/microsoft/monaco-editor/wiki/Monaco-Editor-Accessibility-Guide#keyboard-navigation" style="text-decoration: underline; color: var(--text-normal)">here</a>.</h3>
                            </div>
                        </ButtonWithDialog>
                        <button class="button " @onclick="ToggleSplitView">Split view</button>
                        <button class="button close-button" @onclick="MinimizeEditor">Close</button>
                    </div>
                </div>
                <StandaloneCodeEditor @ref="editor"
                                      Id="csharp-editor"
                                      ConstructionOptions="EditorConstructionOptions"
                                      OnDidChangeModelContent="OnCodeChanged"
                                      OnDidInit="OnEditorInit"/>
                @if (SplitViewEnabled)
                {
                    <SectionNodeTreeExplorer @ref="sectionNodeTreeExplorer" OnTypeClick="OnTypeClick"/>

                }
                <div class="output-controls">
                    <h3 class="output-header">Output</h3>
                    <button class="button clear-button" @onclick="ClearOutput">Clear</button>

                </div>
                @if (SplitViewEnabled)
                {
                    <SectionGbxList OnSelect="OnSelectGbx"/>
                }
                <div class="output-area">
                    <pre class="sysout">@output</pre>
                    <pre class="syserr">@errors</pre>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public EventCallback<GbxModel> OnSelect { get; set; }
    [Parameter]
    public EventCallback<GbxModel> MainTreeCallback { get; set; }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            SplitViewEnabled = LocalStorage.GetItem<bool>(ShowSplitView);
            await JS.InvokeVoidAsync("setDotNetRef", DotNetObjectReference.Create(this));
            availableDlls = await RetrieveAvailableDlls();
            await JS.InvokeVoidAsync("registerProviders");
        }
    }


    #region Overlay

    private bool Expanded { get; set; }
    private bool SplitViewEnabled { get; set; }
    private static string ShowSplitView = "ShowSplitView";

    private SectionNodeTreeExplorer? sectionNodeTreeExplorer;
    private void OnTypeClick(TypeModel type)
    {
        sectionNodeTreeExplorer?.Update();
    }

    private void OnSelectGbx(GbxModel gbx)
    {
        sectionNodeTreeExplorer?.Select(gbx);
    }

    private async Task ToggleSplitView()
    {
        SplitViewEnabled = !SplitViewEnabled;
        LocalStorage.SetItem(ShowSplitView, SplitViewEnabled);
        StateHasChanged();
    }

    private void ExpandEditor()
    {
        Expanded = true;
        MainTreeCallback.InvokeAsync(null);
        StateHasChanged();
    }

    private async Task MinimizeEditor()
    {
        Expanded = false;
        if (noteManager is not null)
        {
            await noteManager.SaveSelectedNoteAsync(updated: false);
        }
        await MainTreeCallback.InvokeAsync(GbxService.SelectedGbx);
        StateHasChanged();
    }

    #endregion

    #region Editor

    private StandaloneCodeEditor? editor;
    private AutocompleteService? autocompleteService;
    private Debouncer debouncer = new();

    private string output = "";
    private string errors = "";

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editorRef)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "csharp",
            Theme = "vs-dark",
            Suggest = new SuggestOptions
            {
                Preview = true,
                ShowInlineDetails = true,
            },
        };
    }

    private async Task OnEditorInit()
    {
        noteManager = new NoteManager(LocalStorage, JS, editor!);

        await noteManager.SelectNoteAsync();
        await UpdateSelectedDlls();
        await JS.InvokeVoidAsync("addMonacoShortcuts");
    }

    private async Task OnCodeChanged()
    {
        await debouncer.DebounceAsync(async () => {
            await ProvideDiagnostics();
        });
    }

    private async Task ProvideDiagnostics()
    {
        var uri = (await editor!.GetModel()).Uri;
        var code = await editor.GetValue();

        if (autocompleteService is null)
        {
            return;
        }
        var diagnostics = await autocompleteService.GetDiagnosticsAsync(code);
        await JS.InvokeAsync<string>("setDiagnostics", diagnostics, uri);
    }

    private void ClearOutput()
    {
        output = "";
        errors = "";
    }

    [JSInvokable]
    public async Task<CompletionResponse> GetCompletionAsync(string code, CompletionRequest completionRequest)
    {
        return await autocompleteService!.GetCompletionAsync(code, completionRequest);
    }

    [JSInvokable]
    public async Task<CompletionResolveResponse> GetCompletionResolveAsync(CompletionResolveRequest completionResolveRequest)
    {
        return await autocompleteService!.GetCompletionResolveAsync(completionResolveRequest);
    }

    [JSInvokable]
    public async Task<SignatureHelpResponse> GetSignatureHelpAsync(string code, SignatureHelpRequest signatureHelpRequest)
    {
        return await autocompleteService!.GetSignatureHelpAsync(code, signatureHelpRequest);
    }

    [JSInvokable]
    public async Task<QuickInfoResponse> GetQuickInfoAsync(QuickInfoRequest quickInfoRequest)
    {
        return await autocompleteService!.GetQuickInfoAsync(quickInfoRequest);
    }

    #endregion

    #region Note

    private NoteManager? noteManager;

    private async Task AddNewNote()
    {
        if (noteManager is null)
        {
            return;
        }
        await noteManager.SaveSelectedNoteAsync(updated: false);
        var note = noteManager.CreateNote();
        await noteManager.SelectNoteAsync(note.Id);
        await UpdateSelectedDlls();
    }

    private async Task OnNoteClick(string noteId)
    {
        await noteManager!.SaveSelectedNoteAsync(updated: false);
        await noteManager.SelectNoteAsync(noteId);
        await UpdateSelectedDlls();
    }

    private async Task RemoveSelectedNote()
    {
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Remove note '{noteManager!.SelectedNote.Name}'?");
        if (confirmed)
        {
            await noteManager.DeleteNoteAsync();
            await UpdateSelectedDlls();
            StateHasChanged();
        }
    }

    private async Task DuplicateSelectedNote()
    {
        await noteManager!.SaveSelectedNoteAsync(updated: false);
        var note = noteManager.CreateNote();
        var selectedNote = noteManager.SelectedNote;
        note.Body = selectedNote.Body;
        note.Name = $"Copy of {selectedNote.Name}";
        note.Refs = selectedNote.Refs.ToList();
        await noteManager.SelectNoteAsync(note.Id);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task SaveNote()
    {
        if (noteManager is null)
        {
            return;
        }
        await noteManager.SaveSelectedNoteAsync();
    }

    private async Task OnNoteNameChanged(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString() ?? "";
        noteManager!.SelectedNote.Name = newValue;
        await noteManager.SaveSelectedNoteAsync(updated: false);
    }

    #endregion

    #region DLL

    private readonly Dictionary<string, MetadataReference> references = [];

    private Dictionary<string, bool> availableDlls = [];

    private async Task<Dictionary<string, bool>> RetrieveAvailableDlls()
    {
        return (await Http.GetStringAsync("refs/available_dlls.txt"))
            .Split("\n")
            .Where(s => !string.IsNullOrEmpty(s))
            .Select(s => s.Trim())
            .ToDictionary(s => s, _ => false);
    }

    private void OnDllCheckboxChanged(string key, object? value)
    {
        if (noteManager is null)
        {
            return;
        }
        if (value is bool b)
        {
            availableDlls[key] = b;
            var selected = noteManager.SelectedNote.Refs;
            if (b)
            {
                selected.Add(key);
            }
            else
            {
                selected.Remove(key);
            }
        }
    }

    private async Task UpdateSelectedDlls()
    {
        foreach (var kvp in availableDlls)
        {
            availableDlls[kvp.Key] = false;
        }
        foreach (var dll in noteManager!.SelectedNote.Refs)
        {
            availableDlls[dll] = true;
        }
        await PrepareSelectedNoteRefs();
        autocompleteService = new(GetSelectedNoteRefsMetadata(), noteManager.SelectedNote.Body);
        await ProvideDiagnostics();
        StateHasChanged();
    }

    private List<MetadataReference> GetSelectedNoteRefsMetadata()
    {
        var selectedRefs = noteManager!.SelectedNote.Refs;
        return references.Where(kvp => selectedRefs.Contains(kvp.Key)).Select(kvp => kvp.Value).ToList();
    }

    private async Task PrepareSelectedNoteRefs()
    {
        var selectedNote = noteManager!.SelectedNote;
        foreach (var dll in selectedNote.Refs.Where(dll => !references.ContainsKey(dll)))
        {
            await using var stream = await Http.GetStreamAsync($"refs/{dll}");
            references.Add(dll, MetadataReference.CreateFromStream(stream));
        }
    }

    #endregion

    #region Export

    private HashSet<string> selectedForExport = [];

    private void ExportSelectAll()
    {
        if (noteManager is not null)
        {
            selectedForExport = noteManager.Notes.Keys.ToHashSet();
        }
    }

    private void ExportUnselectAll()
    {
        selectedForExport.Clear();
    }

    private void OnExportCheckboxChanged(string key, object? value)
    {
        if (value is bool b)
        {
            if (b)
            {
                selectedForExport.Add(key);
            }
            else
            {
                selectedForExport.Remove(key);
            }
        }
    }

    private string PrepareNotesForExport()
    {
        if (noteManager is null)
        {
            return "{}";
        }
        var notes = selectedForExport
            .ToDictionary(noteId => noteId, noteId => noteManager.Notes[noteId]);
        var obj = new
        {
            Notes = notes
        };
        var options = new JsonSerializerOptions
        {
            WriteIndented = true
        };
        var json = JsonSerializer.Serialize(obj, options);
        return json;

    }

    private async Task ExportToFile()
    {
        var text = Encoding.UTF8.GetBytes(PrepareNotesForExport());
        await DownloadService.DownloadAsync("gbx_explorer_notes.json", text);
    }

    private async Task ExportToClipboard()
    {
        var text = PrepareNotesForExport();
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
    }

    #endregion

    #region Import

    private List<Note> DeserializeImport(string json)
    {
        var toImport = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, Note>>>(json);
        if (!toImport?.ContainsKey("Notes") ?? true)
        {
            return [];
        }

        return toImport["Notes"].Values.ToList();
    }

    public async Task OnImportAsync(IBrowserFile file)
    {
        await using var stream = file.OpenReadStream();
        using var reader = new StreamReader(stream);

        var json = await reader.ReadToEndAsync();
        ImportJson(json);

    }

    private async Task ImportFromClipboard()
    {
        var json = await JS.InvokeAsync<string>("navigator.clipboard.readText");
        ImportJson(json);
    }

    private void ImportJson(string json)
    {
        if (noteManager is null)
        {
            return;
        }
        foreach (var note in DeserializeImport(json))
        {
            noteManager.ImportNote(note);
        }
    }

    #endregion

    #region Samples

    private Dictionary<string, string> availableSamples = new()
    {
        {"Compare 2 GBX ", "compare_gbx.sample.json"} ,
        {"Count Blocks ", "count_blocks.json"} 
    };

    private async Task UseSample(string sampleUrl)
    {
        var sampleJson = await Http.GetStringAsync($"samples/{sampleUrl}");
        var sampleDict = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, Note>>>(sampleJson);
        var sample = sampleDict!["Notes"].Values.First();
        
        await noteManager!.SaveSelectedNoteAsync(updated: false);
        
        var note = noteManager.CreateNote();
        note.Body = sample.Body;
        note.Name = sample.Name;
        note.Refs = sample.Refs;
        await noteManager.SelectNoteAsync(note.Id);
        UpdateSelectedDlls();
        
        StateHasChanged();
    }

    #endregion


    [JSInvokable]
    public async Task RunUserCode()
    {
        if (noteManager is null)
        {
            return;
        }
        await noteManager.SaveSelectedNoteAsync();
        await PrepareSelectedNoteRefs();

        var originalOut = Console.Out;
        try
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(noteManager.SelectedNote.Body);

            var compilation = CSharpCompilation.Create("UserCode")
                .AddReferences(GetSelectedNoteRefsMetadata())
                .AddSyntaxTrees(syntaxTree)
                .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            using var ms = new MemoryStream();
            var result = compilation.Emit(ms);

            if (!result.Success)
            {
                errors = string.Join("\n", result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error));
                output = "";
                return;
            }
            if (GbxService.SelectedGbx is null)
            {
                errors = "GBX file is not selected";
                return;
            }

            errors = "";

            ms.Seek(0, SeekOrigin.Begin);
            var asm = Assembly.Load(ms.ToArray());

            var writer = new StringWriter();
            Console.SetOut(writer);

            var runMethod = asm.GetType("Program")?.GetMethod("Run");
            try
            {
                runMethod?.Invoke(null, [GbxService.SelectedGbx.Gbx, EditorServices]);
            }
            catch (Exception ex)
            {
                errors = $"{ex.Message}\n{ex.StackTrace}";
            }

            output = writer.ToString();
        }
        catch (Exception ex)
        {
            output = $"Runtime Error: {ex.Message}\n{ex.StackTrace}";
        }
        finally
        {
            Console.SetOut(originalOut);
            await OnSelect.InvokeAsync(GbxService.SelectedGbx);
        }

        StateHasChanged();
    }
}
